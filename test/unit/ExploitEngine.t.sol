// SPDX-License-Identifier: MIT

pragma solidity ^0.8.18;

import {Test, console} from "forge-std/Test.sol";
import {DSCEngine} from "../../src/DSCEngine.sol";
import {DeployDSC} from "../../script/DeployDSC.s.sol";
import {HelperConfig} from "../../script/HelperConfig.s.sol";
import {MockV3Aggregator} from "../mocks/MockV3Aggregator.sol";
import {ERC20Mock} from "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";
import {ERC20DecimalsMock} from "@openzeppelin/contracts/mocks/token/ERC20DecimalsMock.sol";
import {DecentralizedStableCoin} from "../../src/DecentralizedStableCoin.sol";

contract ExploitEngine is Test {

    DSCEngine engine;
    DecentralizedStableCoin dsc;

    DeployDSC deployer;
    HelperConfig config;

    address weth;
    address wethUsdPriceFeed;
    address wbtc;
    address wbtcUsdPriceFeed;

    address alice = makeAddr("alice");

    uint256 private constant PRECISION = 1e18;
    uint256 private constant FEED_DECIMALS = 1e8;
    uint256 private constant MIN_HEALTH_FACTOR = 1e18;
    uint256 private constant LIQUIDATION_THRESHOLD = 50; // 200% overcollateralized
    uint256 private constant LIQUIDATION_PRECISION = 100;
    uint256 private constant ADDITIONAL_FEED_PRECISION = 1e10;  

    uint256 constant STARTING_ERC20_BALANCE = 10 ether;


    function setUp() public {
        deployer = new DeployDSC();
        (dsc, engine, config) = deployer.run();
        (wethUsdPriceFeed,wbtcUsdPriceFeed,weth,wbtc,) = config.activeNetwork();
        ERC20DecimalsMock(weth).mint(alice, STARTING_ERC20_BALANCE);
        ERC20DecimalsMock(wbtc).mint(alice, STARTING_ERC20_BALANCE);

        

    }
}